/**
 * Core Philosophy for Dresbach Hosting RBAC:
 * This ruleset implements a robust Role-Based Access Control (RBAC) system.
 * It's designed to be secure, scalable, and easy to manage.
 *
 * Key Collections:
 * - /users/{userId}: Stores core user information including their assigned 'role'.
 * - /roles/{roleName}: Defines roles (e.g., "admin", "staff", "client") and the
 *   specific permissions associated with each role (e.g., "clients.read", "services.suspend").
 * - /clients/{clientId}: Contains public-facing client data and nested subcollections
 *   for services, domains, invoices, etc. This maintains compatibility with the
 *   existing frontend structure.
 *
 * Core Security Principles:
 * 1. Default Deny: All access is denied unless explicitly granted.
 * 2. Backend-Driven Roles: The frontend CANNOT alter a user's role. Role assignment
 *    is a privileged backend operation.
 * 3. Granular Permissions: Instead of just checking if a user is an "admin", we check
 *    if their role has the specific permission required for an action (e.g., `hasPermission('clients.delete')`).
 * 4. User Data Privacy: Users can only read their own data from the `/users` collection.
 *    Only admins can list or view other users' data.
 * 5. Path-Based Ownership for Client Data: The `/clients/{clientId}` structure ensures
 *    a user can only access their own services, invoices, etc., by checking if
 *    `clientId == request.auth.uid`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Retrieves the user's role from the `/users` collection.
     * Caches the result in `request.auth.token` for efficiency in subsequent rule evaluations.
     * Returns the role name as a string (e.g., "admin", "client") or null if not found.
     */
    function getUserRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }

    /**
     * Retrieves the list of permissions for a given role name from the `/roles` collection.
     * Returns an array of strings (permissions) or null if the role doesn't exist.
     */
    function getRolePermissions(roleName) {
      let roleDoc = get(/databases/$(database)/documents/roles/$(roleName));
      if (roleDoc.data.permissions[0] == '*') {
          return ['*']; // Special case for admin full access
      }
      return roleDoc.data.permissions;
    }

    /**
     * Checks if the current user's role grants them a specific permission.
     * Supports wildcard '*' permission for full access.
     */
    function hasPermission(permission) {
      if (!isSignedIn()) {
        return false;
      }
      let userRole = getUserRole();
      if (userRole == null) {
        return false;
      }
      let permissions = getRolePermissions(userRole);
      // Check for wildcard or specific permission
      return permissions[0] == '*' || permission in permissions;
    }
    
    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for validating ownership of client-specific data.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Manages user documents, which are the source of truth for roles.
     * @path /users/{userId}
     * @allow (read) Users can read their own document. Users with 'users.read' permission can read any.
     * @allow (list) Only users with 'users.list' permission can list all users.
     * @allow (create, update, delete) Only backend processes (or admins via a trusted backend) should modify user documents.
     *         Client-side writes are disallowed to prevent role escalation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || hasPermission('users.read');
      allow list: if hasPermission('users.list');
      // Writes are restricted. Role changes must be a privileged backend operation.
      allow write: if false; 
    }

    /**
     * @description Manages role definitions. This collection should be read-only for most clients.
     * @path /roles/{roleName}
     * @allow (read) All signed-in users can read role definitions to understand permissions (optional).
     *               Could be restricted further if permission structures are sensitive.
     * @allow (write) Disallowed from the client to prevent tampering with permission sets.
     */
    match /roles/{roleName} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow write: if false; // Only backend/console should manage roles
    }


    /**
     * @description Manages top-level client documents for client-facing data.
     * @path /clients/{clientId}
     * @allow (get) A user can get their own client document, or an admin/staff with 'clients.read'.
     * @allow (list) Only admin/staff with 'clients.list' permission.
     * @allow (create) A new user can create their own client document.
     * @allow (update) A user can update their own data.
     */
    match /clients/{clientId} {
      allow get: if isOwner(clientId) || hasPermission('clients.read');
      allow list: if hasPermission('clients.list');
      allow create: if isOwner(clientId);
      allow update: if isOwner(clientId);
      allow delete: if isOwner(clientId) || hasPermission('clients.delete');

      /**
       * @description Secures all subcollections under a client (services, domains, etc.)
       * @principle A user can only access/modify subcollections under their own client document.
       *            Admin/staff access is governed by specific permissions like 'services.read'.
       */
      match /{subcollection}/{docId} {
         allow get: if isOwner(clientId) || hasPermission(subcollection + '.read');
         allow list: if isOwner(clientId) || hasPermission(subcollection + '.list');
         allow create: if isOwner(clientId) || hasPermission(subcollection + '.create');
         allow update: if isOwner(clientId) || hasPermission(subcollection + '.update');
         allow delete: if isOwner(clientId) || hasPermission(subcollection + '.delete');
      }
    }
    
    /**
     * @description Global collections for admin-level querying.
     * @path /services/{serviceId}, /tickets/{ticketId}
     * @principle Access is restricted to users with the appropriate admin-level permissions.
     *            Regular clients cannot access these top-level collections.
     */
    match /services/{serviceId} {
        allow read: if hasPermission('services.read');
        allow write: if hasPermission('services.write');
    }
    
    match /tickets/{ticketId} {
       allow read: if hasPermission('tickets.read');
       allow write: if hasPermission('tickets.write');
    }
  }
}
